Короткевич Владимир Аполлонович
Короткевич Людмила Ивановна

ООП обьектно-ориентированные технологии и стандарты проектирования

old.gsu.by/whoiswho

<<<Лекция-1>>>

Диктант:
int main()
{
	int a;
	int *b;
	b = &a;
	scanf("%d", b);
	*b *=2;
	printf("%d", *b);
	return 0;
}

		  стек
--------------------
2000	| a = 20
2004	| b = 2000

1 Вопрос
Выделение и освобождение памяти в C++

Для выделения памяти используется оператор new. Память выделяется в куче.
Оператор возвращает адрес на выделеную память.

Освобождение памяти - оператор delete - указатель на освобожденную память.

void main()
{
	int *p;
	p = new int;
	*p = 7;
	int *pm = new int[10];
	pm[2]=4;
	*(pm+2)=4;
	double **pd = new double *[5];
	for(int i=0; i<5; i++){
		pd[i]= new double[10];
	}
	pd[1][2]=3;
	*(*(pd+1)+2) = 3;
	delete p;
	delete[] pm;
	for(int i=0; i<5; i++){
		delete[] pd[i];
	}
	delete[] pd;
}

		  стек		|		  куча
----------------------------------------
2000	| p = 4000	|4000	| 7
		| pm = 4004	|4004	|
		| pd = 4044	|...	|...
		|			|4012	| 4
		|			|...	|...
		|			|4044	|4064
		|			|4048	|4144
		|			|...	|...
		|			|4064	|
		|			|...	|...
		|			|4144	|
		|			|4152	|
		|			|4160	| 3
		|			|...	|...
		|			|		|

2 Вопрос
Переменные ссылки в C/C++

Ссылка это видоизмененная форма описания указателей.
Если ссылка описана и инициирована, то в операторах ее использующих, вместо ссылки читается или модифицируется переменная на которую указывает ссылка.

int value;
int &ref = value;
ref = 10; //value = 10
----
int *ptr = &value;
*ptr = 10;
------
int b = 7;
ptr = &b;
ref = b; //value = 7

Основное назначение ссылок - использование в качестве формальных параметров функций.

void inc_val(int k) {k++;}
void inc_ptr(int *k) {(*k)++;}
void inc_ref(int &k) {k++;}
-----
void main()
{
	int a = 10;
	inc_val(a); //a=10;
	inc_ptr(&a); //a=11;
	inc_ref(a); //a=12;
}

Компилятор анализрует тип формального параметра и если параметр - ссылка, то передается не значение фактического параметра, а его адрес.
Ссылка может являться типом значения возвращаемой функции.

int mas[100];
int item(int ind) {return mas[ind];}

void main()
{
	item(5) = 11;//не выполняется
	int p = item(5);
}
----------------
int mas[100];
int &item(int ind) {return mas[ind];}

void main()
{
	item(5) = 11;//выполняется
	int p = item(5);
}

<<<Лекция-2>>>

3 Вопрос
Значение параметров функции по умолчанию

Для группы последовательностей параметров могут быть заданы значения по умолчанию.

int mult(int val1, int val2 = 2) {
	return val1 * val2;
}

int main()
{
	int a = 5, b = 10, c;
	c = mult(a, b);
	c = mult(c);
	return 0;
}
-------------
int val = 10;
int f(int k) {
	return k * 2;
}
int g(int p = f(val)) {
	printf("\n%d", p);
}

int main()
{
	g(); // 20
	val = 20;
	g(); // 40
	g(50); // 50
	return 0;
}

4 Вопрос
Встроенные или inline функции

Если задано inline, то компилятор во все точки вызова функции вместо команд обращения к ней вставляет тело функции. Это ускоряет работу программы.
Хотя может привести к дополнительному расходу памяти.

inline int Max(int a, int b) {
	return a > b ? a : b;
}

int main()
{
	int x = 10, y = 5, z;
	z = Max(x, y);
	return 0;
}

inline функции не могут содержать операторы ЦИКЛА или оператор switch.

5 Вопрос
Перегрузка функций

Несколько функций с одинаковыми именами, но разным составом параметров.

void showError(char *text) {
	puts(text);
}
void showError(int number) {
	printf("Ошибка номер %d", number);
}
int main()
{
	showError(10);
	showError("Непонятная ошибка");
	return 0;
}

Выбор функции осуществляется в соответствии типов фактических и формальных параметров.
Перегрузка может быть неосуществима из-за наличия параметров по умолчанию или использования ссылок.

void f(int a = 10) ...
void f(int a = 10, int b = 5) ...
int main()
{
	f(); // -
	f(15); // -
	f(10, 20); // +
	return 0;
}
------------------
void f(int a) ...
void f(int &a) ...
int main()
{
	int k;
	f(k); // -
	return 0;
}

Пример процедурной и обьектной программы

Пусть программе требуется хранить сведения о расположении на плоскости геометрических фигур и уметь считать сумму их площадей.

Процедурный подход

int main()
{
	double x[100], y[100], w[100], h[100];
	int num = 0;
	x[num] = 10;
	y[num] = 20;
	w[num] = 8;
	h[num++] = 15;
	x[num] = 40;
	y[num] = 40;
	w[num] = 20;
	h[num++] = 0;
	double s = 0;
	for(int i = 0; i < num; i++) {
		if (h[i] > 0) {
			s += h[i] + w[i];
		} else {
			s += w[i] + w[i] + 3.14;
		}
		...
	}
	return 0;
}

Обьектный подход

class Figure {
	double x, y;
	public:
		Figure(double cx, double cy) {
			x = cx;
			y = cy;
		}
		virtual double sa() = 0;
};

class Rect: public Figure {
	double h, w;
	public:
		Rect(double cx, double cy, double ch, double cw): Figure(cx, cy) {
			h = ch;
			w = cw;
		}
		double sa() {
			return h * w;
		}
};

class Circle: public Figure {
	double z;
	public:
		Circle(double cx, double cy, double cz): Figure(cx, cy), z(cz) {}
		double sa() {
			return r * r * 3.1415;
		}
};

int main() {
	Figure *ptr[100];
	int num = 0;
	ptr[num++] = new Rect(10, 20, 8, 15);
	ptr[num++] = new Circle(40, 40, 20);
	double s = 0;
	for(int i = 0; i < num; i++) {
		s += ptr[i]->sa();
		...
	}
	return 0;
}

Достоинства обьектного подхода:
1. Простота основной программы.
2. Созданная библиотека классов имеет самостоятельное значение, может быть использована в других приложениях. В том числе путем развития за счет создания новых классов на основе существующих.
3. При изменении состава типов фигур (добавления треугольника) не требуется менять основную программу (ее логику).

6 Вопрос
Понятие и описание класса

В C++ могут быть определены новые типы данных путем описания классов.
Класс - новый тип данных.
Описание класса:
ключевое_слово имя_класса { список_членов_класса };

ключевое_слово:
1. class
2. struct
3. union
имя_класса:
имя нового типа данных

В программе можно описать переменные этого типа (обьекты класса), массивы обьектов, указатели и др.

class Student {
	public:
		char name[40];
		int vozrast;
}

int main()
{
	Student s, ms[10], *ps;
	strcpy(s.name, "Иванов");
	ps->vozrast = 20;
	return 0;
}

Члены класса могут быть двух видов:
1. Переменные
2. Функции (методы класса).

Доступ к членам класса:
В методах класса выполняется просто по имени, а в других функциях - с помощью операции "->"(стрелочка) или "."(точка).

Доступом управления с помощью меток:
private: - доступ возможен только в методах класса.
protected: - доступ возможен в методах класса и в методах класса наследника.
public: - доступ возможен во всех функциях.

В классах по умолчанию private.
Для структур по умолчанию public.

... код

		  стек		|		  куча		
----------------------------------------
		| name		|		| name
		| vozrast	|		| vozrast
		| ps		|		|
		|			|		|

<<<Лекция-3>>>

7 Вопрос
Описание функций членов класса

Функции членов класса могут быть описаны полностью внутри класса.

class Student {
	public:
		char name[40];
		int vosrast;
		
		void print() {
			printf("\n%s %d", name, vosrast);
		}
};

void main()
{
	Student s;
	stpcpy(s.name, "Иванов");
	s.vosrast = 18;
	s.print();
}
-----------
void main()
{
	Student s;
	puts("Введите фамилию: ");
	scanf("%s", s.name);
	puts("Введите возраст: ");
	scanf("%d", &s.vosrast);
	Student *ps = new Student;
	puts("Введите фамилию: ");
	scanf("%s", ps->name);
	puts("Введите возраст: ");
	scanf("%d", &ps->vosrast);
}
----------
s.vozrast <=> (&s)->vozrast
ps->vozrast <=> (&*&*ps)->vozrast
----------

При многократном вводе можно описать функцию:

void scan(Student *p) {
	puts("Введите фамилию: ");
	scanf("%s", p->name);
	puts("Введите возраст: ");
	scanf("%d", &p->vosrast);
}

void main()
{
	Student s;
	scan(&s);
	Student *ps = new Student;
	scan(ps);
}
----------
При обьектном подходе:

class Student {
...

void scan {
	puts("Введите фамилию: ");
	scanf("%s", name);
	puts("Введите возраст: ");
	scanf("%d", vosrast);
}
...

void main()
{
	Student s;
	s.scan();
	Student *ps = new Student;
	ps->scan();
}

Возможность описывать структуру обьекта класса и функции обработки данных класса непосредственно внутри класса с возможностью управления доступом к элементам данных и методам класса нзывается инкапсуляцией. Совокупность открытых элементов данных называется интерфейсом класса.

Методы класса могут быть описаны вне класса:

тип имя_класса::имя_метода(параметры)

При этом заголовок метода описывается в классе.

class Point {
	double x,y;
	
	public:
		double getX(){
			return x;
		}
		double getY();
		void setX(double vx);
		void setY(double vy){
			y = vy;
		}
};

double Point::getY() {
	return y;
}
void Point::setX(double vx) {
	x = vx;
}

<<<Лекция-4>>>

8 Вопрос
Конструкторы и деструкторы класса

Методы класса, назначение которых состоит в инициализации обьектов при их создании назваются конструкторами.
Конструкторы вызываются автоматически при создании обьекта любым способом.
Имя конструктора совподает с именем класса. Конструкторы могут быть перегружены.

Если в классе не описан конструктор, то используется конструктор по умолчанию - "пустая функция".

Деструктор вызывается автоматически при уничтожении обьекта.
~имя_класса
Деструктор один, не перегружается, не имеет параметров.
Конструкторы и деструкторы не возвращают значений, для них не указывается тип (даже void).

Пример

class Student
{
	char *name;
	int vozrast;
	public:
		Student(){
			name = new char[40];
			name[0] = '\0';
			vozrast = 0;
		}
		Student(char *n, int v){
			name = new char[40];
			stpcpy(name, n);
			vozrast = v;
		}
		~Student(){
			delete name;
		}
};

void main
{
	Student s;
	Student s1("Иванов", 18);
	Student *ps;
	ps = new Student("П", 20);
	Student ms[5];
	delete ps;
}

		  стек		|		  куча		
----------------------------------------
		| name=2000	| 2000	| name
		| vozrast=0	|		| vozrast
		| name=2040	| 2040	|
		| vozrast=18|		|
		| 			|		|
		|			|		|

Если в классе конструкторы не описаны, то можно создать обьект используя конструктор по умолчанию.
Если же описаны конструкторы с параметрами, но требуется также использовать конструктор без параметров, то он тоже должен быть явно описан.

9 Вопрос
Специальные конструкторы

К специальным конструкторам относятся:
1. конструктор копирования
2. конструктор преобразования (приведения).
Они могут быть вызваны как явно, при создании обьекта, так и не явно.

Конструктор копирования воспринимает единственный обьект, ссылку на обьект того же класса.

void main
{
	Student s("Иванов", 18);
	Student s1 = s; // не корректно
}

		  стек		|	  куча		
----------------------------------------
		| name		| ->| "Иванов\0"
		| vozrast	|	| 
		| name		| -^|
		| vozrast   |	|

class Student{
	...
	Student(Student &a) {
		name = new char[40];
		stpcpy(name, a.name);
		vozrast = a.vozrast;
	}
}

void main
{
	Student s("Иванов", 18);
	Student s1(s); // корректно
	Student s1 = s; // корректно (компилятор различает оператор присваивания и копирования)
}

Если конструктор класса a воспринимает единственный параметр типа b, то конструктор назваются конструктором приведения или преобразования.

class Student{
	...
	Student(char *n){
		name = new char[40];
		stpcpy(name, n);
		vozrast = 0;
	}
}

void main
{
	Student a("Иванов");
	Student b = "Петров";
	b = "Сидоров"; // будет компилировать, но приведет к сбою
}

В последнем варианте создается временный обьект, выполняется копирование из временного обьекта в b и временный обьект уничтожается.
(в переменной обьекта b остается ссылка на освобожденную чать памяти)

Указатель this

В любой нестатический метод класса первым неявным параметром передается указатель на обьект для которого вызван метод.
Этот указатель доступен внутри метода с использованием ключевого слова this.

class Student {
	char *name;
	int vozrast;
	public:
		...
		setVozrast(int v) {
			vozrast = v;
			this->vozrast = v;
			(*this).vozrast = v;
		}
	...
};

int main() {
	Student s;
	s.setVozrast(21);
	return 0;
}

Пусть объекты могут быть связанный список. Голова списка будет находится в глобальной переменной headS, а ссылка на следующий в nextS.
Каждый обьект содержит указатель на след обькт с именем nextS.
В классе студент должен быть реализован метод addToList() с помощью которого студент сам себя добавляет в список.

class Student
{
	public:
		char *name;
		Student *nextS;
		void addToList();
};

Student *headS = NULL;

void Student::addToList() {
	if (headS == NULL) {
		headS = this;
	} else {
		Student *ptr = headS;
		while(ptr->nextS != NULL) {
			ptr = ptr->nextS;
		}
		ptr->nextS = this;
	}
	nextS = NULL;
}

int main()
{
	Student a, b;
	a.addToList();
	b.addToList();
	Student *ps = new Student;
	ps->addToList();
	Student *ptr = headS;
	while(ptr != NULL) {
		stpcpy(ptr->name, "Иванов");
		ptr = ptr->nextS;
	}
}

this может быть значением возвращаемым из метода.
Пример
Пусть обьект после добавления себя в список, возвращает собственный адрес

Student *Student::addToList() {
	...
	return this;
}

void main()
{
	...
	strcpy((new Student)->addToList()->name, "Петров");
	return 0;
}

<<<Лекция-5>>>

10 Вопрос
Инициализация элементов данных классов

Инициализация элементов данных может выполняться с помощью списка инициализации, который указывается в списке конструктора.

имя_конструктора([параметры]):
	элементы_данных(значение)[,...]
	{ тело_конструктора }

class Point
{
	double x,y;
	int color;
	public:
		Paint(double cx, double cy):
			x(cx), y(cy), color(0)
			{ }
};

Список инициализации обязателен, если:
1. Инициализируемый элемент является константой:

class Point
{
	...
	const int color;
	public:
		Paint(double cx, double cy, int c):
			x(cx), y(cy), color(c)
			{ }	
};

void main()
{
	Paint p(10, 5, -2, 0xFFFFFF);
}

2. Если элемент данных сам является обьектом класса, имеющего конструктор с параметрами:

class Circle
{
	Point center;
	double radius;
	public:
		Circle(double cx, double cy, double cr):center(cx, cy) {
			radius = cr;
		}
};

11 Вопрос
Наследование классов

Наследование это механизм порождения новых классов на основе существующих. При этом новые классы содержат элементы данных и методы (новые)(порожденные) исходных, при этом функцианальность методов базовых классов может быть в определенных пределах изменена. Классы наследники могут содержать дополнительные элементы данных, собственные методы или перекрывать (заменять) методы базового класса.

Синтаксис подтверждения закрытия окна

class Base
{
	...
};

class Arrived : ключ_доступа Base [, ключ_доступа, base1 ...]
{
	...
};

class Arrived: ключ_доступа Base
{
	...
};

Хотя члены базового класса входят в состав наследников, доступ к ним управляем и является минимальным из уровня доступа описанного в базовом классе и ключа доступа указанного в описании наследования.

ключ_доступа: private, protected, public.

class Student
{
	char name[40];
	public:
		char *getName() {
			return name;
		}
		void setName(char *n) {
			strcpy(name, n);
		}
};

class ZStudent: public Student
{
	public:
		char work[100];
};

void main()
{
	Student s;
	s.setName("Иванов");
	ZStudent z;
	z.setName(s.getName());
}

Для обьектов классов наследников могут без ограничений вызываться открытые методы базовых классов.

Указателям на класс можно без ограничений присваивать адреса элементов наследников.
Обратное возможно только при явном приведении типа.

Student *ps;
ps = &z;
ps = new ZStudent;

------------

ZStudent *pz;
pz = &s; // ошибка

//но можно так
pz = (ZStudent *)&s;

В классе наследнике может быть перекрыт метод базового класса путем описания метода с тем же именем и составом параметров.

class Student
{
	...
	public:
		void print() {
			printf("\n%s", name);
		}
};

class ZStudent : public Student
{
	...
	public:
		void print() {
			printf("\n%s%s", getName(), work);
		}
};

void main()
{
	...
	s.print();
	z.print();
	
	ps = &z; // ???
	ps->print(); // вызов из студента
}

В методе наследника можно вызвать перекрытый метод базового класса.

class ZStudent : public Student
{
	...
	public:
		char work[100];
		void print() {
			Student::printf();
			printf("\n%s", work);
		}
};

12 Вопрос
Вызов конструкторов и деструкторов при наследовании

При создании обьекта наследника, до его конструктора всегда вызывается конструктор базового класса.

Деструкторы выделения в обратной последовательности.

Если требуется вызвать конструктор базового класса имеющий параметры, то этот метод задается в списке инициализации конструктора-наледника.

Рассмотрим на примере
Пусть фамилия студента и место работы заочника хранятся в динаически выделенной памяти - куче.

class Student
{
	char *name;
	public:
		Student(char *n) {
			name = new char[40];
			strcpy(name, n);
		}
		~Student() {
			delete [] name;
		}
};

class ZStudent: public Student
{
	char *work;
	public:
		ZStudent(char *n, char *w):Student(n) {
			work = new char[100];
			stpcpy(work, w);
		}
		~ZStudent() {
			delete [] work;
		}
};

void main()
{
	ZStudent *pz = new ZStudent("Иванов", "IBA");
	...
	delete pz;
}

		  стек		|	  куча		
----------------------------------------
		| pz		| ->| name XX
		| 			|	| work XX
		| 			| 	| "Иванов" X
		| 		    |	| "IBA" X

13 Вопрос
Лабораторная работа №5 Коллекция
Разработать коллекцию обьектов вашего класса

Обьект коллекция должен содержать массив указателей на обьект базового класса, а также переменную - текущее количество обьектов в коллекции, текущее количество обьектов базового класса адреса которых сохранены в массиве.

Обьекты храянщиеся в коллекции длжны быть выделены динамически.

<<<Лекция-6>>>

14 Вопрос
Множественное наследование

Класс наследник может иметь несколько прямых базовых классов.

class Student
{
	char name[40];
	public:
		Student(char *n) {
			stpcpy(name, n);
		}
		void setName(char *n) {
			stpcpy(name, n);
		}
	...
};

class Book
{
	char name[100];
	public:
		Book(char *n) {
			stpcpy(name, n);
		}
		void setName(char *n) {
			stpcpy(name, n);
		}
	...
};

Определим класс библиотечной выдачи книг студенту.

class Vidacha:public Student, public Book
{
	char date[11];
	public:
		Vidacha(char *ns, char *nb, char *dt):Student(ns), Book(nb) {
				stpcpy(date, dt);
			}
		void set(char *ns, char *nb, char *dt) {
			Student::setName(ns);
			Book::setName(nb);
			stpcpy(date, dt);
		}
	...
};

void main()
{
	Vidacha v("Иванов", "C++", "19.03.2019");
}

При множественном наследовании вызываемые методы базовых классов в качестве this передается адрес той части обьекта наследника, которая соответствует обьекту базового класса.

void main()
{
	Vidcha v("Иванов", "C++", "19.03.2019");
	v.set("Петров", "С#", "18.03.2019");
	
	Student *ps=&v; //можно
	Book *pb=&v; //нельзя
	
	ps->setName("C"); //незя, непалучица
}

Использование множественного наследования может привести к многократному вхождению обьекта базового класса в обьект наследник.

		 Факультет
		 /	    \
  Кафедра 	     Группа
		|		 |
   Препад 		 Студент
		 \	    /
		  Оценка
		
Проблемма решается определением общего класса как виртуального базового для своих наследников. (virtual)

class Facult { ... };
class Cafedra:virtual public Facult { ... };
class Teacher:public Cafedra { ... };
class Group:virtual public Facult { ... };
class Student:public Group { ... };
class Ocenka:public Teacher, public Student { ... };

15 Вопрос
Статические члены класса

При описании членов класса для них может быть указано ключевое слово static.
Статические элементы класса - данные существуют в единственном экземпляре независимо от количества обьектов, в том числе при отсутствии обьектов.
Такой член класса является общим для всех обьектов. Для его хранения должна быть описана глобальная переменная в формате:

тип имя_класса::имя_перем[=значение];

Статические методы могут быть вызваны даже при отсутствии обьектов класса.
Статические методы могут обрабатывать только статические элементы данных и вызывать только статические методы класса.
Обращение к статическим методам класса возможно через операцию (точка). , (стрелка)-> , имя_класса:: .
В статические методы класса не передается указатель this.

Рассмотрим пример:
Пусть обьекты класса студент содержат размер стипендии студентов.
Требуется получать в любой момент времени сумарную стипендию по всем существующим обьектам.

class Student
{
	char name[40];
	double stip;
	static double sumStip;
	public:
		Student(char *n, double s = 0) {
			stpcpy(name, n);
			stip = s;
			sumStip += s;
		}
		~Student() {
			sumStip -=stip;
		}
		void setStip(double s) {
			sumStip -= stip;
			sumStip += s;
			stip = s;
		}
		double getStip() {
			return stip;
		}
		static double getSumStip() {
			return sumStip;
		}
};

double Student::sumStip = 0;

void main()
{
	Student s("Иванов", "100");
	Student *ps = new Student("Петров", "150");
	ps->setStip(120);
	printf("%lf", Student::getSumStip()); // 120
	delete ps;
	printf("%lf", Student::getSumStip()); // 100
	...
}

Достоинство статических элементов данных: они могут быть закрытыми.

16 Вопрос
Друзья класса

Есть понятие дружественности.
Предположим есть класс вектор и матрица. Они скрывают свое содержимое, но содержат методы доступа к своим элементам, контролирующие методы - параметров индексов. Требуется разработать глобальную функцию умножающую матрицу на вектор.

class Vector
{
	double v[10];
	public:
		double &item(int ind) {
			if (ind >= 0 && ind < 10)
				return v[ind];
			puts("err");
			return v[0];
		}
};

class Matrix
{
	Vector m[10];
	public:
		double &item(int i, int j) {
			if (i >= 0 && i <10)
				return m[i].item(j);
			puts("err");
			return m[0].item(0);
		}
};

Функция умножение матрицы на вектор

Vector mutiply(Matrix x, Vector y) {
	Vector temp;
	for(int i = 0; i < 10; i++) {
		double s = 0;
		for(int j = 0; j < 10; j++)
			s += x.item(i, j) * y.item(j);
		temp.item(i) = s;
	}
	return temp;
}

Недостаток реализации это выполнение контроля индекса, на что уходит лишнее время.
Проблема могла бы быть решена если бы можно было некоторым функциям разрешить доступ к закрытой части класса.
Это достигается описанием дружественности.

class Vector
{
	double v[10];
	public:
		double &item(int ind) {
			if (ind >= 0 && ind <10)
				return v[ind];
			puts("err");
			return v[0];
		}
	...
	friend Vector mutiply(class Matrix &m, Vector &v); // class для избежания ошибки компиляции
};

class Matrix
{
	Vector m[10];
	public:
		double &item(int i, int j) {
			if (i >= 0 && i <10)
				return m[i].item(j);
			puts("err");
			return m[0].item(0);
		}
	...
	friend Vector mutiply(Matrix &m, Vector &v);
};

Vector mutiply(Matrix x, Vector y) {
	Vector temp;
	for(int i = 0; i < 10; i++) {
		double s = 0;
		for(int j = 0; j < 10; j++)
			s += x.m[i].v[j] * y.v[j];
		temp.v[i] = s;
	}
	return temp;
}

<<<Лекция-7>>>

Другом класса может быть метод другого класса.

friend void B::g();

Все методы одного класса могут быть друзьями другого класса.

friend class B;

Свойства дружественности:
1. Описание дружественности не зависит от меток public, protected, private.
2. Дружественность не симметрична, не наследуется и не является переходным свойством.

class A
{
	int f;
	friend class B;
};

class B
{
	int g;
};

class C:public A
{
	int x;
};

class D:public B
{
	
};

17 Вопрос
Перегрузка операторов (операций)

C++ обеспечивает перегрузку операторов или операций, тоесть определение действий по этим операторам над обьектами класса.

Описание перегрузки представляет собой описание функции которая вызывается вместо оператора, примененного к обьектам класса.

Цели перегрузки:
1. Обеспечить наглядность записи
2. Реализация специфических действий вместо стандартной реализации операторов в C++
3. Возможность использования стандартных универсальных алгоритмов для обработки обьектов.

2.:
class Student
{
	char *name;
	public:
		Student(char *n) {
			name = new char[40];
			strcpy(name, n);
		}
}

void main()
{
	Student a("Иванов"), b("Петров");
	a = b; // не верно
}

		  стек		|	  куча		
----------------------------------------
	a	| name		| 	| "Иванов"
	b	| name		|	| "Перов"
		| 		    |	|

Перегрузка оператора возможна двумя способами:
1. Определение глобальной функции
2. Определение функции члена класса

Рассмотрим глобальную функцию

тип operator знак_операции(параметры)

Определим класс куча_картошки

class Bulba
{
	public:
		double ves;
		double cena;
		Bulba() {
			ves = 0;
			cena = 0;
		}
		Bulba(double v, double c) {
			ves = v;
			cena = c;
		}
	...
};

//1
Bulba operator + (Bulba b1, Bulba b2) {
	Bulba temp;
	temp.ves = b1.ves + b2.ves;
	temp.cena = (b1.ves * b1.cena + b2.ves * b2.cena) / temp.ves;
	return temp;
}

//2
void operator += (Bulba &b1, Bulba b2) {
	b1.cena = (b1.ves * b1.cena + b2.ves * b2.cena) / (b1.ves + b2.ves);
	b1.ves += b2.ves;
}

//3
Bulba &operator += (Bulba &b1, Bulba b2) {
	b1.cena = (b1.ves * b1.cena + b2.ves * b2.cena) / (b1.ves + b2.ves);
	b1.ves += b2.ves;
	return b1;
}

Bulba &operator += (Bulba &b1, double v) {
	b1.ves += v;
	return b1;
}

void main()
{
	Bulba a(100, 1), b(200, 2), c;
	c = a + b; // (300, 1.67);
	
	a += b;
	c += a += b;
	(c += a) += b;
	
	a += 100;
}

В случае если оператор перегружается глобальной функцией, эта функция описывается как друг класса.

Если оператор перегружается методом класса, то он вызывается для обьекта, являющегося первым операндом операции.

class Bulba
{
	...
	Bulba operator + (Bulba b2);
	Bulba &operator += (Bulba &b1, Bulba b2);
	Bulba operator + (double v);
};

Bulba Bulba::operator + (Bulba b2) {
	b2.cena = (b2.ves * b2.cena + ves * cena) / (b2.ves + ves);
	b2.ves += ves;
	return b2;
}

Bulba &Bulba::operator += (Bulba &b1, Bulba b2) {
	cena = (b2.ves * b2.cena + ves * cena) / (b2.ves + ves);
	ves += b2.ves;
	return *this;
}

Bulba Bulba::operator + (double v) {
	Bulba t;
	t.cena = cena;
	t.ves = ves + v;
	return t;
	// или
	return Bulba(ves + v, cena);
}

void main()
{
	Bulba a(100, 1), b(200, 2), c;
	c = a + b; // (300, 1.67);
	
	a += b;
	c += a += b;
	(c += a) += b;
	
	a += 100;
	
	a = b + 100;
}

Свойства перегрузки
1. Приоритеты операций сохраняются при перегрузке.
2. Хотя бы один операнд операции должен иметь имя класса или операция должна быть методом класса.
	(нельзя перегрузить операцию исключительно встроенным типом данных)
3. Некоторые операции могут быть перегружены только как члены класса. (в частности присваивание)
4. Все операции наследуются, кроме операции присваивания.
5. Компилятор различает использование конструктора копирования и перегруженные операции присваивания.
6. Если необходимо различать префиксную и постфиксную формы операторов ++ нужно указать фиктивный параметр типа int.
	Bulba operator ++(); // ++a;
	Bulba operator ++(int); // a++;
7. Функции operator не могут иметь параметры со значением по умолчанию.

<<<Лекция-8>>>

18 Вопрос
Полиморфизм и позднее связывание

Полиморфизм - множественность форм, механизм, позволяющий в классе наследнике менять функционирование методов базового класса путем переопределения виртуальных функций, определенных в базовом классе.

Пусть в классе Student существует метод вывода обьекта на экран, который перекрывается в классе наследнике. Пусть в функции main описан и заполнен массив указателей на обьекты класса студент, причем элементы массива могут содержать адреса как базового класса, так и наследника.

void main()
{
	Student *ptr[100];
	ptr[0] = new Student("Иванов");
	ptr[1] = new ZStudent("Петров", "Гомкаб");
	...
	for(int i = 0; i < 20; i++) {
		ptr[i]->print();
	}
}

Будет вызван метод базового класса так как компилятор ориентируется на тип указателя ptr[i] и выбор метода осуществляет еще при компиляции программы.
Это называется раннее или обычное связывание.
Если функцию print определить как virtual, те:

class Student
{
	...
	virtual void print()...
};

class ZStudent:public Student
{
	...
	virtual void print()...
};

то выбор функции будет осуществляться во время выполнения программы в соответствии с типом для которого вызывается метод print.
Это называется позднее связывание.

В наследнике указывать virtual не обязательно.

Пусть обьекты класса Student хранят полученные студентом оценки, метод вывода студентов на экран выводит фамилию и средний балл студента рассчитанный специальным методом, при этом средний балл считатся без учета неудовлетворительных оценок.

Класс разрабатывался на момент 2005 года:

class Student
{
	char name[40];
	int ocens[50];
	int count;
	public:
		Student(char *n) {
			stpcpy(name, n);
			count = 0;
		}
		void addOcen(int oc) {
			ocens[count++] = oc;
		}
		double sredball() {
			double s = 0;
			int n = 0;
			for(int i = 0; i < count; i++) {
				if(ocens[i] > 2) {
					n++;
					s += ocens[i];
				}
			}
			return n > 0 ? s/n : 0.0;
		}
		void print() {
			print("\n%s%0.2lf", name, sredball());
		}
};

-------

class Student
{
	...
	protected:
		virtual int addOcen(int oc) {
			return 2;
		}
	...
};

class Student2019:public Student
{
	...
	protected:
		int addOcen(int oc) {
			return 3;
		}
	public:
		Student2019(char *n):Student(n)
		{ }
	...
};

Свойства virtual метода:
1. static функция не может быть virtual
2. Конструкторы не могут быть virtual, а деструкторы могут

class Student
{
	char *name;
	...
	virtual ~Student() {
		delete name;
	}
};

class ZStudent:public Student
{
	char *work;
	...
	~ZStudent() {
		delete work;
	}
};

void main()
{
	Student *ps = new ZStudent;
	...
	delete ps; // вызовется деструктор только базового класса, если нет слова virtual в классе Student 
}

Реализация механизма virtual функций (реализация позднего связывания)

1. Для каждого класса, содержащего virtual функции, компилятор создает таблицу адресов этих функций VTAB - таблица virtual методов. При этом адрес любой virtual функции имеет одно и тоже смещение внутри VTAB для базового класса и всех наследников.
2. В каждый обьект класса компилятор включает указатель на таблицу VTAB. Указатель называют VPTR. VPTR распологается перед всеми пременными первого базового класса со всеми виртуальными функциями.
3. В начало каждого конструктора компилятор включает код для заполнения VPTR адресом VTAB.
4. При вызове virtual функции из обьека вызывается VPTR, из VTAB адрес функции и затем она вызывается.

class A
{
	int a1, b1;
	void func();
};

Обьект A

Смещение|	Переменная
0		|	a1
4		|	b1

class B:public A
{
	int a2, b2;
	virtual void f();
	virtual void g();
};

Обьект B

Смещение|	Переменная
0		|	a1
4		|	b1
8		|	VPTR
12		|	a2
16		|	b2

VTAB B

Смещение|	Функция
0		|	B::f()
4		|	B::g()

class C:public B
{
	int a3;
	void g();
	virtual void h();
};

Обьект C

Смещение|	Переменная
0		|	a1
4		|	b1
8		|	VPTR
12		|	a2
16		|	b2
20		|	a3

VTAB C

Смещение|	Функция
0		|	C::f()
4		|	C::g()
8		|	C::h()

class D:public C
{
	int a4;
	void f();
	void h();
};

Обьект D

Смещение|	Переменная
0		|	a1
4		|	b1
8		|	VPTR
12		|	a2
16		|	b2
20		|	a3
24		|	a4

VTAB D

Смещение|	Функция
0		|	D::f()
4		|	C::g()
8		|	D::h()

void main()
{
	B *p = new D;
	p->f(); //вызовет из D
	p->g(); //вызовет из С
	p->h(); //отругает
}

----------------------

class Student
{
	char name[40];
	int vozrast;
	int stip;
	...
	Student() {
		memset(this, 0, sizeof(Student)); // VTAB ошибки, если есть виртуальные функции
	}
};

class Student
{
	...
	Student(char *n) {
		strcpy(name, n);
	}
};

class ZStudent:public Student
{
	char *work;
	...
	ZStudent(char *n, char *w):Student(n) { //правильно
		stpcpy(work, w);
	}
	
	ZStudent(char *n, char *w) { //неправильно
		Student(n);
		stpcpy(work, w);
	}
};

<<<Лекция-9>>>

19 Вопрос
Чистые виртуальные функции, абстрактные классы

При описании базового класса может быть задан прототип virtual функции, при этом тело функции вообще не определяться.

virtual тип имя([параметры]) = 0;

Пример - функция рассчета площади для класса Figure.
Такие функии называются чистыми виртуальными функциями. Класс в котором есть хотябы одна чистая виртуальная функция называется абстрактным.
В классах наследниках чистая виртуальная функция должна быть переопределена или же наследник тоже будет абстрактным классом.
Чистые виртуальные функции описываются для того чтобы гарантировать их переопределение в классах наследниках, так как обьекты абстрактных классов создавать нельзя.

void main()
{
	Figure f; //x
	Figure *p = new Figure; //x
}

Указатели и ссылки на обьекты типа Figure описывать можно.

<<<Лекция-10>>>

20 Вопрос
Значение библиотеки потоков в C++
Предопределенные обьекты-потоки

Ввод-вывод данных реализуется специальной библиотекой классов - библиотекой потоков.
Основное назначение библиотеки потоков это процесс преобразования обьектов находящихся в памяти компьютера в строку байтов и перенос их на внешнее устройство и наоброт.

Достоинства потоковых средств по сравнению с функциями C:
1. Надежность
printf, scanf не контралируют тип обрабатываемых данных. Механизм потоков основывается на перегрузке операции, что приводит к автоматическому вызову функии соответствующего типа данных.
2. Расширяемость
Благодяря наследованию и полиморфизму, разаработанные функии могут работать с потоками различных стилей. Можно предусмотреть собственные перегруженные операции, которые позволят библиотеке потоков работать с обьектами класса.
3. Простота и последовательность

Основные классы библиотеки потоков

				  --> ifstream -----------------------------
				 |											|
	 --> istream  --> isstream_withassign					|
	| 			 |											|
	|			 |				--> fstream	------------	|
	|			 |			   |						|	|
	| 			  --> iostream  --> iostream_withassign	|	|
	|			 |										|	|
ios	 --> ostream  --> osstream_withassign				|	|
	|			 |										|	|
	|			  --> ofstream							|	|
	|													|	|
	|		 -------------------------------------------	|
	|		|												|
	|		V												|
	 --> ifstreambase <-------------------------------------

Существует 4 предопределенных обьекта-потока. Эти обьекты создаются автоматически в начале программы и унитожаются в конце.

cin - буферизованный поток ввода. Обьект ксасса istream_wa.
cout - буферизованный поток ввывода. Обьект класса ostream_wa.
cerr - не буферизованный поток для ошибок.
clog - не буферизованный поток для вывода протокола программы.

ios - содержит базовые средства ввода вывода. Обьект этого класса обычно не создается.
istream - поддерживает форматированные и неформатированные преобразование данных при вводе.
ostream - поддерживает форматированные и неформатированные преобразование данных при выводе.
iostream - поддерживает форматированные и неформатированные преобразование данных и при вводе и при выводе.
fstreambase - базовое средство работы с файлами (открытие, закрытия, сброса).
ifstream, ofstream, fstream - файловые потоки, ввод вывод.

21 Вопрос
Опервции помещения в поток и извечения из потока

2 основных класса - istream и ostream.

ostream используют для вывода операцию << (операция помещения в поток)
istream использует для ввода операцию >> (операция извлечения из потока)

void main()
{
	char name[40];
	cout << "Введите имя";
	cin >> name;
	cout << "Привет,";
	cout << name;
}

Кроме реализации ввода вывода, оперыции возвращают ссылку на поток, являющиеся первым операндом. Это позволяет обьединять операции ввода вывода в цепочки.

cout << "Привет," << name;

22 Вопрос
Методы ввода вывода
_____________________________
Для вывода для класса ostream

1. ostream &put(char); - вывод символов в поток
2. ostream &write(char *buf, int len); - в поток выводит len произвольных символов находящихся по адресу buf. Обычно используется для файловых потоков

cout << 'a';
cout.put('a');
cout.put('a') << 'b';
____________________________
Для ввода для класса istream

1. int get(); - ввод символа
2. istream &get(char&); - ввод символа
3. int peek(); - возвращает следующий символ без его удаления из потока
4. istream &putback(char); - возвращает символ в поток
5. istream &get(char *buf, int len, int ogran='\n'); - вводит len - 1 символ или до ограничителя, который остается в потоке.
6. istream &getline(char *buf, int len, int ogran='\n'); - тоже что и get, но ограничитель удаляется из потока.
7. istream &read(char *buf, int len); - ввод len произвольных символов для файловых потоков
8. istream &ignore(int len, int ogran=EOF); - пропустить len символов в потоке или до ограничителя
9. int gсout(); - количество байт, введенных в последней операции

cin >> ch;
ch = cin.get();
cin.get(ch);

void main()
{
	char name[40];
	int tabnum = -1;
	count << "Введи фамилию или таб. номер";
	char ch = cin.peek();
	if (ch >= '0' && ch <= '9')
		cin >> tabnum;
	else
		cin >> name;
}

void main()
{
	char name[40];
	cout << "Введи фамилию";
	cin.get(name, 40);
	if (cin.get() != '\n')
		cout << "Ошибка";
}

<<<Лекция-11>>>

23 Вопрос
Ввод вывод для пользовательских типов данных

Для ввода вывода обьектов пользовательских типов данных могут быть перегружены операции левого и правого сдвигов.

Пример:

class Complex
{
	public:
		double re, im;
		Complex(double r, double i) {
			re = r;
			im = i;
		}
	...	
};

void main()
{
	Complex z(7.2, -1.0);
	cout << z; // (7.2, -1.0)
}

ostream &operator << (ostream &s, Complex c) {
	s << '(' << c.re << ',' << c.im << ')';
	return s;
}

Пусть допустимой формой ввода комплексного числа это f, (f),  (f, f).

istream &operator >> (ostream &s, Complex &c) {
	double re, im = 0;
	int error = 0;
	char ch;
	s >> ch;
	if (ch != '(') {
		s.putback(ch);
		s >> re;
	}
	else {
		s >> re >> ch;
		if (ch == ',') s >> im >> ch;
		if (ch != ',') error = 1;
	}
	if (error == 0) {
		c.re = re;
		c.im = im;
	}
	else
		cout << "Неверный формат данных";
	return s;
}

void main()
{
	Complex z(7.2, -1.0);
	cin >> z;
}

24 Вопрос
Состояние потока

В классе ios присутствует переменная state - это битовая шкала, где отображаются сведения об ошибках ввода вывода.

ios::goodbit // 0x00 - все в порядке
ios::eofbit // 0x01 - обнаружен конец файла
ios::failbit // 0x02 - ошибка форматирования или преобразования
ios::badbit // 0x04 - серьезная ошибка ввода вывода
ios::hardfail // 0x08 - нисправимая ошибка ввода вывода

Если установлен в единицу хотябы один бит state, то операции ввода вывода блокируются пока state не будет очищен.

Методы работы со state:
int good(); // возвращает не ноль (true) если все в порядке
int rdstate(); // возвращает значение переменной state
int eof(); // не ноль (true) если конец файла
int fail(); // не ноль (true) если установлен любой бит ошибки
int bad(); // не ноль (true) если серьезная неустранимая ошибка
void clear(int = 0); // параметр заносится в поле state

Перегружено сравнение потока с нулевым указателем. Возвращается null если установлен знак ошибки.

istream &operator >> (ostream &s, Complex &c) {
	double re, im = 0;
	char ch;
	s >> ch;
	if (ch != '(') {
		s.putback(ch);
		s >> re;
	}
	else {
		s >> re >> ch;
		if (ch == ',') s >> im >> ch;
		if (ch != ')') s.clear(ios::failbit);
	}
	if (s) {
		c.re = re;
		c,im = im;
	}
	else
		cout << "Неверный формат данных";
	return s;
}

25 Вопрос
Форматирование данных при вводе и выводе

Существует 3 вида средств форматирования:
1. Функции форматирования
2. Флаги форматирования
3. Манипуляторы

Манипуляторы - функции, имена или вызов которых включаются в цепочке операций ввода вывода, что позволяет задавать параметры форматирования данных.
Различают:
1. Непараметризованные параметры (указывается только имя манипулятора)
2. Параметризованные параметры (указывается вызов функции)

Непараметризованные

ws - пропуск начальных пробелов при вводе
left / right / internal - выравнивание по левой правой границе или знак числа слева, а число справа
dec / ocе / hex - вывод в десятичной, восьмеричной и шеснадцатеричной формах
endl - '\n'
ends - '\0'

scientific / fixed - форма вывода числа с плавающей точкой

setw(int) - ширина поля вывода, действует на вывод следующего числа или строки
setfill(int) - заполняет символом пробелы
setprecision(int) - длина дробной части в форматах scientific / fixed, если не установлено, то общее количество цифр
setiosflags(int) - указывает флаги форматирования, которые должны быть доступны
resetiosflags(int) - переустанавливает флаги форматирования, которые должны быть доступны

int v = 20;
cout << left << setw(50) << name << v;

26 Вопрос
Резидентные потоки (не под запись)

<<<Лекция-12>>>

27 Вопрос
Файловые потоки

Классы файловых потоков имеют конструкторы без параметров:
ifstream()
ofstream()
fstream()
Создается файловый поток без привязки к файлу.
Классы файловых потоков имеют конструкторы с параметрами:
ifstream(char *name, int omode = ios::in, int prot=filebuf::openprot)
ofstream(char *name, int omode = ios::out, int prot=filebuf::openprot)
fstream(char *name, int omode, int int prot=filebuf::openprot)

omode - режим открытия файла:
ios::in - открытие на чтение
ios::out - открытие на запись
ios::ate - после открытия переходит в конец файла
ios::app - для выходных файлов - дописывание
ios::trunc - для выходных файлов очистка содержимого
ios::nocreate - файл должен существовать
ios::noreplace - файл не должен существовать
ios::binary - файл двоичный

prot - режим доступа к новому файлу
S.IREAD
S.IWRITE
Новый файл можно и писать и читать.

Если обьект создан конструктором без параметров, то можно привязать к нему файл методом open(char *name, int omode, int prot)
Закрытие файла выполняется при закрытии обьекта или методом close()

Пример: Программа копирования файлов.

Имена входного выходного файлов получает из командной строки.

void error(char *txt1, char *txt2 = "") {
	cerr << txt1 << ',' << txt2;
	exit(1);
}

void main(char argc, char *argv[])
{
	if (argc != 3) error("Неверное количество параметров.");
	istream from(argv[1], ios::in | ios::binary);
	if (!from) error("Ошибка открытия", argv[1]);
	ofstream to(argv[2], ois::out | ios::binary);
	if (!to) error("Ошибка открытия", argv[2]);
	char buf[4096];
	int len;
	while ((len = from.read(buf, 4096).gcount()) != 0)
		to.write(buf, len);
	if (!from.eof() || !to) error("шибка открытия", argv[2]);
}

28 Вопрос
Позиционирование в потоке

Поток рассматривается как массив байтов. Можно указать номер байта. Для установки указателя чтения используется void seeky(long pos, int dir = ois::beg);
dir = ois::beg
dir = ois::end
dir = ois::cur

long tellg() - возвращает текущую позицию.

Для указателя записи в потоке использует seekp tellp

29 Вопрос
Шаблоны классов

Шаблон классов - представляет собой шаблон на основе которого могут быть построены другие классы.

Пример: Класс целых чисел

class array
{
	int *buf;
	public:
		array(int n) {
			buf = new int [n];
		}
		~array() {
			delete [] buf;
		}
		int &operator [] (int ind) {
			return buf[ind];
		}
}

Может быть определен шаблонный класс позволяющий создавать на своей основе шаблоны любого типа.

template <class Type>
template <typename Type>

template <typename Type>
class array
{
	Type *buf;
	public:
		array(int n) {
			buf = new Type [n];
		}
		~array() {
			delete [] buf;
		}
		Type &operator [] (int ind) {
			return buf[ind];
		}
}

void main()
{
	array<int> a(100);
	array<double> b(200);
}

Параметрами шаблона могут быть константы.

template <typename Type, int size>
class array
{
	Type buf[size];
	public:
		Type &operator [] (int ind) {
			return buf[ind];
		}
}

void main()
{
	array<int, 100> a, d;
	a = d;
}

Методы шаблонного класса могут быть заданы вне шаблонного класса.

template <typename Type, int size>
void array<Type>::имя_метода([параметры]){}

Обьекты шаблонных классов считаются боьектами одного класса при совпадении всех параметров.

30 Вопрос
Шаблонyные функии

Семейства функций совпадающих алгоритмически, но различающихся типом параметров могут быть описаны ввиде одной шаблонной функции.

int Max(int x, int y) { return x > y ? x : y; }

template<class Type>
Type Max(Type x, Type y) { return x > y ? x : y; }

При cout << Max("Иванов", "Петров"); сравнит адреса.

Чтобы избежать:
char *Max(char *x, char *y) { return shomp(x, y) > 0 ? x : y; }

Шаблонная ф-я Type может сравнивать обьекты любых, но совпадающих типов.

Параметры шаблона должны обязательно хотябы раз присутствовать среди параметров шаблонной функии.

14.04.19 кр
1. Описание класса
	методы, конструкторы
2. Наследование
3. Перегрузка
	перегрузки как член класса и как друг класса
4. Виртуальная функция
5. Шаблонная функция

<<<Лекция-13>>>

31 Вопрос
Описание свойств класса

В простейшем случае свойства класса - это переменная члена класса, доступ к которой реализуется через методы класса.

__property тип_всойства имя = { [read = способ_доступа], [write = способ_доступа], [index = целое] };

способ_доступа - имя переменной члена класса (получение или присваивание значения свойству) или имя метода класса.
Для read метод без параметра возвращает значение свойства.
Для write единственный параметр с тем же свойством что и у read..

class Student
{
	char name[40];
	int vozrast;
	public:
		__property char *Name = { read = name, write = setName };
		__property int Vozrast = { read = vozrast, write = setVozrast };
	private:
		void setName(char *n) { stpcpy(name, n); }
		void setVozrast(int v) {
			if (v < 12 && v > 80)
				cerr << "Не верно!";
			else
				vozrast = v;
		}
};

void main()
{
	Student s;
	s.Name = "Иванов";
	cout << s.Name;
	s.Vozrast = 10;
}

Для хранения значений группы однотипных свойств можнт быть использован масси данных соответствующего типа.
Для таких свойств задается параметр index это целая константа, которая передается в  методы доступа к свойству.
read write могут быть указаны только методы с одним или двумя параметрами.

class Rect
{
	double bounds[4];
	double getBound(int n) { return bounds[n]; }
	void setBound(int n, double val) { bounds[n] = val; }
	public:
		__property double Left = { read = getBound, write = setBound, index = 0 }
		__property double Top = { read = getBound, write = setBound, index = 1 }
		__property double Right = { read = getBound, write = setBound, index = 2 }
		__property double Bottom = { read = getBound, write = setBound, index = 3 }
};

void main()
{
	Rect r;
	r.Left = 20;
	r.Right = 40;
	Rect r1;
	r1.Left = r.Right + 50;	
}

Может быть описан массив свойств

__property тип имя [int имя] = { [read = метод], [write = метод] }

Методы имеют один или два параметра

Опишем класс Week

class Week
{
	...
	public:
		__property char *DayOfWeek[int n] = { read = getDOW }
	private:
		char *getDOW(int ind) {
			switch(ind) {
				case 1: return "Понедельник";
				case 2: return "Вторник";
				case 3: return "Среда";
				case 4: return "Четверг";
				case 5: return "Пятница";
				case 6: return "Суббота";
				case 7: return "Воскресенье";
				default: return "Выходной";
			}
		}
};

void main()
{
	Week w;
	cout << w.DayOfWeek[2]; 
}

32 Вопрос
Обработка ошибок в C++

Предположим что некая функия при своей работе обнаружила ошибку.
Возможные действия
1. Завершить программу
	(иногда завершение не допустимо)
2. Возвратить значение трактуемое как ошибка или установить глобальный признак ошибки.
	(недостаток - признак приходится проверять при каждом вызове функции)
3. Игнорировать ошибку, оставив программу в неопределенном состоянии
	(недопустимый вариант)
4. Вызвать функцию специально предназначенную для обработки ошибки, что не решает проблему окончательно

Ситуация усугубляется при разработке библиотек или класоов.
Разработчик библиотеки может обнаружить ошибку, но не знает какая должна быть реакция на нее.
Программист использующий библиотеку может написать реакцию, но не может обнаружить ошибку.
Для решения проблемы введено понятие особой ситуации.
Функция, обнаружившая ошибку, создает ситуацию, в ращете что обработать ошибку может функция прямо или опоследованно ее вызвавшая.
Эти особые ситуации называются исключениями.

Пусть есть класс Vector

class Vector
{
	double *p;
	int size;
	public:
		Vector(int n) {
			size = n;
			p = new double[n];
		}
		~Vector() {
			delete p;
		}
		double &operator [] (int i);
};

Исключение это обьект какого-либо типа (обычно обьект класса)

class ErrRange
{};

double &Vector::operator[](int i)
{
	if (i >= 0 && i < size)
		return p[i];
	ErrRange er;
	throw er;
}

Функция выбросившая исключение завершается, после чего корректно завершаются все функции по цепочке вызова до той функии, которая умеет обрабатывать выброшенное исключение.

Для того чтобы исключение было обработано используется оператор try

try {
	программа где может возникнуть исключение
}
catch (тип [имя]) {
	обработчик ошибки
}

Блоков catch  может быть несколько для разных видов исключения. Последним может быть catch(...) - любое исключение.

Пример:

void main()
{
	Vector v(100);
	try {
		...
		work(v);
		...
	}
	catch (ErrRange) {
		обработка ошибки
	}
}

void work(Vector q) {
	...
	crash(Vector v);
	...
}

void crash(Vector p) {
	...
	p[-1] = 5;
	...
}

В блоке catch может быть указано имя обрабатываемого обьекта исключения.

class ErrRange
{
	public:
		int index;
		ErrRange(int i) {
			index = i;
		}
};

void main()
{
	Vector v(100);
	try {
		...
		work(v);
		...
	}
	catch (ErrRange er) {
		cerr << "Неверный индекс = " << er.index;
	}
}

При завершении функии по цепочки вызова с вызовом декструктора уничтожаются обьекты находящиеся в стеке, но не освобождается память выделенная в куче.
Это можно обеспечить написав оператор try с блоком finally. Содержимое этого блока выполняется всегда обязательно.

try {
	
}
finally {
	
} 

finally and catch одновременно использовать нельзя, но можно использовать вложенные операторы try.

<<<Лекция-14>>>

33 Вопрос
Вопрос

STL
string
#include <string>

using namespace std;

Класс string определяет строку.

string s, s1 = "Иванов", s2 = s1;

Перегруженные операции [] = + += < <= > >= == != << >>

Место под данные в string выделяются в куче, а размер буфера в точности соответствует длине строки.

Методы

char *c_str() - указатель на буфер строки (где данные находятся)
char *data() - указатель на буфер строки (где данные находятся)

resize(int len) - устанавливает длину буфера строки, это позволяет не расширять строку при добавлении данных

s1.substr(0, 4) - вырезает подстроку из строки

33 Вопрос
Шаблонный класс вектор

Это контейнерный класс для хранения других классов, в котором...

Память под массив обьектов при необходимости расширяется.

Конструкторы

vector<Student> vs1;
int n = 100;
vector<Student> vs2(100);

Для доступа к элементам вектора можно использовать []
Для доступа к элементам контейнерного класса могут использоваться обьекты итераторы.

vector<Student>::iterator it;

Итератор обеспечивает доступ к обьекту

Перегруженные операции [] ++ -- + - += -=

если доступна операция только ++, итератор явл последовательным FwdIt
если ++ --, то BidIt
если, nj RndIt

методы
begin() - возвращает итератор на первый элемент
end() - возвращает итератор на следующий за последним элемент

for (it = vs2.begin(); it != vs2.end(); it++) { }

Добавление обьектов vector

void push_back(Student &s)

Класс vector<bool>

Путь файл ocens.txt
Иван
10
9
10
0
Петр
7
4
0

void main()
{
	vector<string> names;
	vector<vector<int>> ocens;
	string name;
	ifstream from("ocens.txt");
	int k = 0;
	while(!from,eof()) {
		from >> name;names.push_back(name);
		vector<int> socens;
		ocens.push_back(socens);
		while(!from.eof()) {
			char ch = from.peek();
			if (ch <'0' || ch > '9')
				break;
			int ocen;
			from >> ocen;
			ocens[k].push_back(ocen);
			k++;
		}
	}
	from.close();
	vector<double> sred;
	for ()int i = 0; i < k; i++) {
		double sum = 0;
		vector<int>::iterator it;
		for (it = ocens[]i.begin(); it != ocens[i].end(); it++)
		sum += *it;
		if (ocens[i].size() > 0)
			sum /= ocens[i].size();
		sred.push_back(sum);
	}
}
